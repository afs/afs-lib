/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.seaborne.lib.uuid;

import java.net.NetworkInterface;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.Clock;
import java.time.Instant;
import java.util.Enumeration;
import java.util.UUID;

import org.apache.commons.math3.random.MersenneTwister;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.jena.atlas.AtlasException;
import org.apache.jena.atlas.lib.BitsLong;
import org.apache.jena.atlas.lib.Bytes;

/**
 * Generator for version1 UUID in {@linkplain java.util.UUID}.
 *
 * Usage:
 * <pre>
 *    java.util.UUID uuid = UUD
 * </pre>
 *
 * See <a ref="https://tools.ietf.org/html/rfc4122">RFC 4122</a> UUID.
 */
public class UUIDCreatorV1 implements UUIDCreator {
    /*
    Version 1:
    60 bits of time
    48 bits of nodeId
    14 bits of clock sequence
     2 bits variant (bits in clk_seq_hi_res - 0 and 1 as in the RFC picture.
     4 bits version (in time_hi_and_version).

    Caution:
    Accessing Java longs has bit 0 as least significant bit for reading/wriing bots.
    RFC 4122 has teh most significant bit at bit 0.


    Below, the  RFC 4122 picture is bit-centric.
    with MostSignificantLong (time) then LeastSignificantLong(clk,node).

    Bit 0 below corresponds to the high bit, bit 63 of LeastSignificantLong.
    and time_low is bits 32 to 63 (inclusive).

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          time_low                             |   8 hex digits
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       time_mid                |         time_hi_and_version   |   4-4
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |   4-
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         node (2-5)                            |   12
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    */

    // Code actually uses "BitsLong.unpack"
    // MostLeast significant long
    private static final long maskTimeLow    = 0xFFFFFFFF00000000L;
    private static final long maskTimeMid    = 0x00000000FFFF0000L;
    private static final long maskTimeHigh   = 0x0000000000000FFFL;
    private static final long maskVersion    = 0x000000000000F000L;

    // Least significant long
    private static final long maskVariant    = 0xC000000000000000L;
    private static final long maskClockSeq   = 0x3FFF000000000000L;
    private static final long maskNode       = 0x0000FFFFFFFFFFFFL;

    /*package*/ static final int VERSION  = 1 ;
    /*package*/ static final int VARIANT  = 2 ;

    // The number of UUIDs to allocate (incrementing the timestamp) before reading
    // the system clock again.
    //
    // Each reading of the clock allows this many UUIDs to be generated by sequentially incrementing
    // the time_low field.  Then we read the clock again and reset the time.
    // 2020-04:
    //    Block size 10, spin on same time - ~3 million/s, sleep(1) ~ 25K/s
    //      Example (2020-04-19) jump: e2cce2b5 to e2ccf472 : about 0x1000 = 4096
    //    Block size 1 (read time each time) and spin on same time, is a rate about 1 million/s.
    //
    // The notional time (last_time+uuids_this_tick) can get slightly ahead of actual
    // time if we allocate very (very) fast, we pause when reading the system clock next so it
    // can never be more than UUIDS_PER_BLOCK ahead (if that is set to 10, that means 1 microsecond,
    // except the current time clock isn't smooth.
    //
    // Providing that is less that restart time, (and clock_seq and node are the same),
    // this is safe. NB clock_seq is 14 bits of random number (16 million) as well.
    private static final long UUIDS_PER_BLOCK = 25;

    // How many bits to use for the clock sequence. Maximum 14.
    // Smaller number leave a signature fixed hex pattern in the UUID.
    private static final int CLOCK_BITS = 14;

//    // Milliseconds. Set to about the frequency interval of the system clock, if used.
//    private final long DELAY_MS = 1;

    // Whether to use the MAC address or a 48 bit random number (actually 46 bits of random because
    // 2 bits are used to make sure it does not clash with a real MAC address).
    /*package*/ static final boolean USE_REAL_ADDRESS = true;

    // Generator variables.

    // Units: 100ns units since the Gregorian Epoch, 00:00:00.00, 15 October 1582, +00:00
    private long uuid_time = 0;
    // Timestamp is (uid_time+uuids_this_tick)
    private long uuids_this_tick = 0;
    // Clock sequence - 14 bits of random to stop two clocks being the same.
    private final int clockSeq;

    // Node - 48 bits.
    private final long node;

    // Time control: Units:100ns ticks. (RFC 4122 name of variable).
    private long time_last = 0;

    /*package*/ UUIDCreatorV1() {
        long random = nextLong();
        // Both node id and clock sequence from a single call to the random number
        // generator. Different bit slices are used by the two calls.
        clockSeq = calcClockSeq(random);
        node = calcNodeId(random);
        // Forces the clock to be read first time a UUID is generated.
        uuids_this_tick = UUIDS_PER_BLOCK+1;
        time_last = 0;
    }

    /** Generate a UUID version 1 from this generator */
    @Override
    public UUID create() {
        // This implementation free runs for UUIDS_PER_BLOCK, incrementing uuids_this_tick.
        // Then it resets the clock, checking the clock has moved forward enough.
        long timestamp = 0;
        synchronized (this) {
            if ( uuids_this_tick >= UUIDS_PER_BLOCK ) {
                // Sets
                // uuids_this_tick
                // time_last = new start of tick time.
                // uuid_time 
                setTime();
            }
            timestamp = uuid_time + uuids_this_tick;
            uuids_this_tick++;
        }
        return generate(timestamp);
    }

    // clockSeq and node are stable.
    @Override
    public int hashCode() {
        long x = clockSeq<<48 | node ;
        return ((int)(x >> 32)) ^ (int)x;
    }

    @Override
    public boolean equals(Object obj) {
        if ( this == obj )
            return true;
        if ( obj == null )
            return false;
        if ( getClass() != obj.getClass() )
            return false;
        UUIDCreatorV1 other = (UUIDCreatorV1)obj;
        return clockSeq == other.clockSeq && node == other.node;
    }

//    /** Return the stable key for this generator */
//    private Object key() {
//        long x = ((long)clockSeq << 48) | node ;
//        return x;
//    }

    private UUID generate(long timestamp) {
        return generate(VERSION, VARIANT, timestamp, clockSeq, node);
    }

    private static UUID generate(int version, int variant, long timestamp, int clockSeq, long node) {
        long timeHigh = timestamp >>> (60 - 12);       // Top 12 bits of 60 bit number.
        long timeMid = (timestamp >>> 32) & 0xFFFFL;   // 16 bits, bits 32-47
        long timeLow = timestamp & 0xFFFFFFFFL;        // Low 32 bits
        return generate(version, variant, timeHigh, timeMid, timeLow, clockSeq, node);
    }

    private static UUID generate(int version, int variant, long timeHigh, long timeMid, long timeLow, int clockSeq, long node) {
        long mostSigBits = (timeLow << 32) | (timeMid << 16) | (version << 12) | timeHigh;
        long leastSigBits = ((long)variant << 62) | ((long)clockSeq << 48) | node;
        return new UUID(mostSigBits, leastSigBits);
    }

    // Set uuid_time and lastTime, clear uuids_this_tick.

    // Called from create, inside synchronized.
    private void setTime() {
        // Wait for a clock tick.
        long time_now = 0;

        // This does not reduce the allocation rate significantly.
        //synchronized(this)
        {
            for(;;) {
                time_now = nowSystemTicks();
                // Calculation in 100ns ticks
                if ( time_now > time_last+uuids_this_tick )
                    // Clock time has moved ahead of our last+number of UUIDs.
                    break;
                // Need to wait until the time gets ahead of us.
                // The system clock may be quite coarse and the overhead of Thread.sleep(1)
                // quite high.
                // Spin or uncomment.
                //    try { Thread.sleep(DELAY_MS); }
                //    catch (java.lang.InterruptedException e) {} // ignore exception
                // Try again...
            }
        }
        // Time is now ahead of last_time.
        uuids_this_tick = 0;
        time_last = time_now;
        // Convert to the UUID base time (00:00:00.00, 15 October 1582)
        // That's the date of the Gregorian calendar reforms.
        // See the RFC 4122 text quoted for the number, the epoch differnt in 100ns units.
        // Java base time is is January 1, 1970.
        uuid_time = time_now + 0x01B21DD213814000L;
    }

    // Current time, from the OS system epoch base,
    /*package*/ final static long dev_nowSystemTicks() { return nowSystemTicks(); }    
    
    // Reported in 100ns units but granularity is more like 10-20 units (1-2us).
    private final static long nowSystemTicks() {
        if ( false ) {
            // Old style.
            long x = System.currentTimeMillis();
            return x*10*1000;
        }
        Instant instant = Clock.systemUTC().instant();
        long seconds = instant.getEpochSecond();
        int nanos = instant.getNano();
        long ticks = seconds*10*1_000_000+(nanos/100);
        return ticks;
    }

    private static int calcClockSeq(long random) {
        // Can also set the clock sequence number to increase the randomness.
        // Use up to 14 bits for the clock (actually, it's 14 bits as
        // strays into the variant).
        // We use less to get a characteristic "-80??-" in the string
        int clockSeq = 0;
        if ( CLOCK_BITS != 0 )
            clockSeq = (int)BitsLong.unpack(random, 48, (48 + CLOCK_BITS)); // 48+14 = 62 => no overshoot.
        return clockSeq;
    }

    private static long calcNodeId(long random) {
        long node = 0;
        // Get the MAC address of an interface.
        // The loopback I/F does not have a MAC address.
        // This code address with "ifconfig"/"uuid -d" as to bit order for the node based on the MAC address.
        if ( USE_REAL_ADDRESS ) {
            try {
                Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces();

                byte[] hwAddr = null;
                while(en.hasMoreElements()) {
                    NetworkInterface ni = en.nextElement();
                    if ( ni == null || ni.isLoopback() || ni.isPointToPoint() || ni.isVirtual()  )
                        continue;
                    hwAddr = ni.getHardwareAddress();
                    if ( hwAddr != null )
                        break;
                }
                if ( hwAddr != null && hwAddr.length > 4 ) { // Length is a sanity check.
                    for ( byte bv : hwAddr ) {
                        node = (node << 8) | (bv&0xFF);
                    }
                    return node;
                }
            } catch (Exception ex) { }                      // Failed in some way.  Fallback.
        }

        // https://en.wikipedia.org/wiki/MAC_address
        // Based on a random number.
        // Other random factors go into the clockSeq (14 bits) leading to 14+46 bits of random = 60 bits.

        // Unicast vs. multicast : least significant bit of an address's first octet is 0 (zero) => unicast
        //      Bit 40 = 1 => multicast

        // Universally administered and locally administered addresses are
        // distinguished by setting the second-least-significant bit of the first
        // octet of the address.
        // Global/local
        //     Bit 41 = 1 => local

        // Unicast vs. multicast : least significant bit of an address's first octet is 0 (zero) => unicast
        //      0 => unicast : bit 40 in the long).
        // Global vs local : 0 => local : bit 1 of the 48 bit address (bit 41 in the long).
        node = BitsLong.unpack(random, 0, 48);  // Low 48bits
        // This is to agree with Linux: uuid(1).
        node = BitsLong.set(node, 40);        // Local
        node = BitsLong.set(node, 41);        // Unicast
        return node ;
    }

    // Localise the use of the random number generator e.g. easily use SecureRandom
    // and avoid the dependency for Apache Commons Math3.

    private long nextLong() {
        return randomGenerator.nextLong();
    }

    // -- Implementation : org.apache.commons.math3.random.MersenneTwister, seeded
    // with 128 bits from SecureRandom.getInstance("NativePRNGNonBlocking").generateSeed(32);

    private final RandomGenerator randomGenerator = createRandom();

    private static RandomGenerator createRandom() {
        // http://www0.cs.ucl.ac.uk/staff/d.jones/GoodPracticeRNG.pdf
        int intsInSeed = 8;
        byte[] seedBytes = calcSeed(intsInSeed*Integer.BYTES);

        int[] seedInts = new int[intsInSeed];
        // Convert to int[] because that is what Apache Commons math3 MersenneTwister uses.
        for ( int i = 0 ; i < intsInSeed ; i++) {
            seedInts[i] = Bytes.getInt(seedBytes, 4*i);
        }

        // Mersenne Twister: https://en.wikipedia.org/wiki/Mersenne_Twister
        // Period: 2^19937 − 1
        //   624 integer seed variables (19,968 bits).
        // We use 8 ints, 256 bits (and in particular, more than 128 we use for UUIDs.)
        // The seed is jump into the sequence of numbers the PRNG generates.

        // Going too long may cause problems because not enough entropy has been collected
        // since the startup of the system.
        // NativePRNGNonBlocking is non-blocking (on Linux, uses /dev/urandom)
        // and is sufficient for non-cryptographic use.

        //Default Mersenne Twister seed is the long System.currentTimeMillis() + System.identityHashCode(this)
        RandomGenerator rg = new MersenneTwister(seedInts);
        return rg;
    }

    private static byte[] calcSeed(int bytes) {
        String algorithm = "NativePRNGNonBlocking";
        try {
            return SecureRandom.getInstance(algorithm).generateSeed(bytes);
        } catch (NoSuchAlgorithmException e) {
            throw new AtlasException("Failed to get the SecureRandom generator", e);
        }
    }

    // -- Implementation : Code using JDK SecureRandom.

//    private final Random randomGenerator = createRandom();
//    private static Random createRandom() {
//        // SecureRandom objects are safe for use by multiple concurrent threads.
//        // JVM:
//        // https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms
//        // NativePRNG - default
//        // NativePRNGBlocking - Uses /dev/random, and is blocking.
//        // NativePRNGNonBlocking - Uses /dev/urandom, and is non-blocking.
//        // SHA1PRNG - Random start, increments each time and reapplies SHA1.
//
//        try {
//            // man urandom =>
//            // """As a general rule, /dev/urandom should be used for everything except long-lived GPG/SSL/SSH keys."""
//            // Uses /dev/urandom
//            String name = "NativePRNGNonBlocking";
//            SecureRandom sRandom = SecureRandom.getInstance(name);
//            return sRandom;
//        } catch (NoSuchAlgorithmException e) {
//            throw new RuntimeException(e);
//        }
//    }
}

